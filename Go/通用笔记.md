# Go 笔记
##目录
- [函数](#函数)
- [关于第三方包](#关于第三方包)
- [json](#json)

#### 函数
- 函数可以赋值给变量
- 函数可传任意类型的不定参数
  - 就是函数的参数和每个参数的类型都不是固定的。
  - 用interface{}传递任意类型数据是Go语言的惯例用法，而且interface{}是类型安全的,eg:
    - func myfunc(args ...interface{}){}
- 当函数的返回值有多个的时候，用"_"标识符，用来忽略函数的某个返回值
- “裸”返回
  - 没有参数的 return 语句返回各个返回变量的当前值
  - 应当用在的短函数中。在长的函数中它们会影响代码的可读性
  - 这是隐式返回
- Golang返回值不能用容器对象接收多返回值。只能用多个变量，或 “_” 忽略。
- 命名返回参数可被同名局部变量遮蔽，此时需要显式返回


#### 关于第三方包
- go mod tidy, 能解决相关包已经在机子上但依赖不了的问题

### json
- 构造json（用字符串），并unmarsh到map里
```go
jsonStr := `
  {
      "userName":"admin",
      "nick_name":"管理员",
      "info":{
         "age":18
      },
      "extra":[
         {
            "address":"上海市"
         },
         {
            "address":"北京市"
         }
      ]
   }`
anyMap := make(map[string]interface{}, 0)
if err := json.Unmarshal([]byte(jsonStr), &anyMap); err != nil {
  panic(err)
}
fmt.Println("result:", anyMap)
```
- struct能被转换的字段都是首字母大写的字段，但如果想要在json中使用小写字母开头的key，可以使用struct的tag来辅助反射。
```go

type TestNode struct {
	Name string `json:"id"`
	Na   string `json:"workflow_urn"`
	Bb   int    `json:"created_time"`
}

type TestNode2 struct {
	Name string
	Na   string
	Bb   int
}

func main() {
	node := &TestNode{}
	jsonStr := `
    {
        "id":"asdf",
		"workflow_urn":"afsdd",
		"created_time":3
	}`
	node2 := &TestNode2{}
	jsonStr2 := `
    {
        "Name":"asdf",
		"Na":"afsdd",
		"Bb":3
	}`

	if err := json.Unmarshal([]byte(jsonStr), &node); err != nil {
		panic(err)
	}
	fmt.Println("result:", node)

	if err := json.Unmarshal([]byte(jsonStr2), &node); err != nil {
		panic(err)
	}
	fmt.Println("result:", node)

	if err := json.Unmarshal([]byte(jsonStr), &node2); err != nil {
		panic(err)
	}
	fmt.Println("result:", node2)

	if err := json.Unmarshal([]byte(jsonStr2), &node2); err != nil {
		panic(err)
	}
	fmt.Println("result:", node2)
}
```
